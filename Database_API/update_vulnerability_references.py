#!/usr/bin/python3
from Database_API import Xerxes_SQL
#from Controller import export_files
import logging
import datetime
from os import remove, rename
from Naked.toolshed.shell import muterun_rb
from xml.dom import minidom
import shutil
import json
import filecmp
import urllib.request

# This code updates the local CloudSQL CVE and CMS Vulnerabilities databases

def check_local_WPScan_for_update():
    vp_need_update = False
    vt_need_update = False
    vp_file_name = "/home/logan/Desktop/wpscan/data/plugins.json"
    vp_current_file_name = "/home/logan/Desktop/wpscan/data/current_plugins.json"
    vt_file_name = "/home/logan/Desktop/wpscan/data/themes.json"
    vt_current_file_name = "/home/logan/Desktop/wpscan/data/current_themes.json"
    try:
        shutil.copyfile(vp_file_name, vp_current_file_name)
    except:
        logging.debug("Error: <" + vp_file_name + "> not found, must force update")
        print("Error: <" + vp_file_name + "> not found, must force update")
        vp_need_update = True
    try:
        shutil.copyfile(vt_file_name, vt_current_file_name)
    except:
        print("Error: <" + vt_file_name + "> not found, must force update")
        logging.debug("Error: <" + vt_file_name + "> not found, must force update")
        vt_need_update = True
    if not vp_need_update or not vt_need_update:
        response = muterun_rb("../Scanners/wpscan/wpscan.rb --no-color --no-banner --update")
        #print(response)
        logging.info("WPScan Response Code {} updating at: {}".format(response.exitcode, datetime.datetime.now()))
        if response.exitcode != 0:
            logging.error("Error calling WPScan Update " + str(datetime.datetime.now()))
            print("Error calling WPScan Update " + str(datetime.datetime.now()))
            return
        else:
            vp_need_update = not(filecmp.cmp(vp_file_name, vp_current_file_name))
            vt_need_update = not(filecmp.cmp(vt_file_name, vt_current_file_name))
    if vp_need_update:
        update_local_WPScan_database(vp_file_name, "Plugin")
    if vt_need_update:
        update_local_WPScan_database(vt_file_name, "Theme")

def update_local_WPScan_database(updated_file, type):
    out_file_name = "updated_WordPress_plugins.csv"
    out_file = open(out_file_name, "w")
    with open(updated_file) as wp_vulnerability_file:
        extensions = json.load(wp_vulnerability_file)
        for extension in extensions:
            if extensions[extension]['latest_version'] is not None:
                version_str = extensions[extension]['latest_version']
            else:
                version_str = "n/a"
            for vulnerability in extensions[extension]['vulnerabilities']:
                out_file.write(extension + ";" + type + ";WordPress;n/a;" + version_str + ";" + vulnerability['title']+"\n")
    wp_vulnerability_file.close()
    out_file.close()

    db = Xerxes_SQL.connect_database()
    cursor = db.cursor()
    load_statement = "LOAD DATA LOCAL INFILE '" + out_file_name + "' \
    IGNORE INTO TABLE CMS_VULNERABILITIES \
    FIELDS TERMINATED BY ';' \
    LINES TERMINATED BY '\\n' \
    (EXTENSION_NAME, EXTENSION_TYPE, CMS, MIN_VERSION, MAX_VERSION, ATTACK_DESCRIPTION);"

    try:
        cursor.execute(load_statement)
    except:
        db.rollback()
        logging.error("Update Error for {}s".format(type))
        print("Update Error: Can't update table")
    else:
        db.commit()
        logging.info("Updated WordPress Vulnerable {}s".format(type))
    remove(out_file_name)

def update_local_CVE():

    CVE_new_file_name = "new_CVE.csv"
    CVE_current_file_name = "current_local_CVE.csv"

    urllib.request.urlretrieve("https://cve.mitre.org/data/downloads/allitems.xml", "new_CVE.xml") # Downloading the current raw XML file

    xmldoc = minidom.parse("new_CVE.xml")               # Begin processing
    formatted_file = open(CVE_new_file_name, "w")
    CVE_entries = xmldoc.getElementsByTagName('item')   # Gets list of CVE items

    for entry in CVE_entries:
        formatted_file.write(("{};,;{};,;{}\n").format(entry.attributes['name'].value, entry.getElementsByTagName("status")[0].childNodes[0].data, entry.getElementsByTagName("desc")[0].childNodes[0].data))

    remove("new_CVE.xml")   # Removing to save storage
    formatted_file.close()

    # Comparisons done with csv instead of keeping local xml for lower storage overhead
    if not (filecmp.cmp(CVE_new_file_name, CVE_current_file_name)): # If the files are not the same
        new_set = {}
        old_set = {}
        with open(CVE_new_file_name, 'r') as new_file:
            try:
                new_contents = new_file.read().splitlines()
                new_set = set(new_contents)
            except:
                logging.error("Encoding error for new CVE entries, update failed.")
                exit(-1)
        with open(CVE_current_file_name, 'r') as old_file:
            try:
                old_contents = old_file.read().splitlines()
                old_set = set(old_contents)
            except Exception as e:
                logging.error("Encoding error for old CVE entries, update failed", e)
                exit(-1)
        for diff in new_set-old_set:    # Inserting/replacing ONLY entries with updated information
            diff_fields = diff.split(";,;")
            Xerxes_SQL.insert_into_CVE_vulnerabilities(Xerxes_SQL.connect_database(), diff_fields[0], diff_fields[1], diff_fields[2])
        logging.info("Updated Local CVE Database at {}".format(datetime.datetime.now()))


    remove(CVE_current_file_name)                       # Remove old file for space
    rename(CVE_new_file_name, CVE_current_file_name)    # Keep the new one for comparison for next update

if __name__ == "__main__":
    #logging.basicConfig(filename=export_files.LOGS_DIR + '/xerxes-controller.log', format='[%(levelname)s] %(asctime)s \
                                                   #%(filename)s:%(funcName)s %(lineno)d %(message)s')
    logging.info("Performing update check at {}".format(datetime.datetime.now()))
    check_local_WPScan_for_update()
    update_local_CVE()
